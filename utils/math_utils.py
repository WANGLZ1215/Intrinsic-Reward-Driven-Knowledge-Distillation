"""
Mathematical Utility Functions
Function: Provide mathematical utility functions including answer extraction, validation, etc.
"""

import re
import sympy as sp
import numpy as np
from typing import Optional, List, Tuple, Union
import logging


def extract_answer_unified(text: str) -> Tuple[str, Optional[float]]:
    """
    Unified answer extraction function - supports multiple formats (robust version)
    This is the only answer extraction implementation in the project, other modules should call this function
    
    Supported formats (in priority order):
    1. #### (GSM8K standard format) - highest priority
    2. \\boxed{} (LaTeX format)
    3. "answer:" or "answer：" or "答案是" (Chinese: "the answer is")
    4. "The answer is" or "the answer is"
    5. Fallback: last number (only when containing keywords like answer/final/结果 (Chinese: "result"))
    
    ⚠️ Important: Do not remove special characters (especially #) to maintain format integrity
    
    Args:
        text: Input text (containing reasoning process and answer)
        
    Returns:
        (Answer text, Answer number)
        - Answer text: Extracted original answer string
        - Answer number: Converted to float, None if extraction fails
    """
    if not text:
        return "", None
    
    # Only replace newlines with spaces, preserve all other characters (including #, $, =, etc.)
    text_clean = text.replace("\n", " ").replace("\r", " ").replace("\t", " ")
    
    # First priority: GSM8K standard #### format (preserve # symbol)
    matches = re.findall(r"####\s*(-?\d+\.?\d*)", text)
    if matches:
        # Use last match (usually the final answer)
        answer_text = matches[-1]
        try:
            return answer_text, float(answer_text)
        except ValueError:
            pass
    
    # Second priority: \boxed{} format
    matches = re.findall(r"\\boxed\{(-?\d+\.?\d*)\}", text)
    if matches:
        answer_text = matches[-1]
        try:
            return answer_text, float(answer_text)
        except ValueError:
            pass
    
    # Third priority: "answer:" or "answer：" or "答案是" (Chinese: "the answer is")
    matches = re.findall(r"[Aa]nswer[:：]?\s*(-?\d+\.?\d*)", text)
    if matches:
        answer_text = matches[-1]
        try:
            return answer_text, float(answer_text)
        except ValueError:
            pass
    
    # Fourth priority: "The answer is" or "the answer is"
    matches = re.findall(r"[Tt]he answer is\s*(-?\d+\.?\d*)", text)
    if matches:
        answer_text = matches[-1]
        try:
            return answer_text, float(answer_text)
        except ValueError:
            pass
    
    # Fifth priority: Fallback - extract last number
    # ⚠️ Only use when containing keywords like answer/final/结果 (Chinese: "result") to avoid extracting intermediate calculation numbers
    text_lower = text.lower()
    if any(keyword in text_lower for keyword in ["answer", "final", "结果", "答案是", "the answer", "conclusion"]):
        matches = re.findall(r"-?\d+\.?\d*", text)
        if matches:
            # Try to extract last number
            answer_text = matches[-1]
            try:
                return answer_text, float(answer_text)
            except ValueError:
                pass
    
    return "", None


def extract_final_answer(text: str) -> str:
    """
    Extract final answer from text (returns text only)
    
    Note: This function calls the unified extract_answer_unified function.
    Kept for backward compatibility.
    
    Args:
        text: Input text
        
    Returns:
        Extracted answer text
    """
    answer_text, _ = extract_answer_unified(text)
    return answer_text


def extract_gsm8k_answer(text: str) -> str:
    """
    Extract answer specifically for GSM8K dataset
    
    Note: This function calls the unified extract_answer_unified function.
    Kept for backward compatibility.
    
    Args:
        text: Text containing reasoning process and answer
        
    Returns:
        Extracted answer text
    """
    answer_text, _ = extract_answer_unified(text)
    return answer_text


def validate_gsm8k_answer(student_text: str, correct_answer: str) -> bool:
    """
    Validate if GSM8K answer is correct
    
    Args:
        student_text: Complete text generated by student (containing reasoning process)
        correct_answer: Correct answer
        
    Returns:
        Whether the answer is correct
    """
    # Extract answer from student text
    student_answer = extract_gsm8k_answer(student_text)
    
    # Compare answers
    return is_answer_correct(student_answer, correct_answer)


def extract_number_from_answer(answer: str) -> Optional[float]:
    """
    Extract number from answer
    
    Args:
        answer: Answer text
        
    Returns:
        Extracted number, None if extraction fails
    """
    if not answer:
        return None
    
    # Find numbers
    numbers = re.findall(r'-?\d+\.?\d*', answer)
    if numbers:
        try:
            return float(numbers[-1])
        except ValueError:
            return None
    
    return None


def is_answer_correct(student_answer: str, correct_answer: str, 
                     tolerance: float = 1e-6) -> bool:
    """
    Determine if student answer is correct
    Optimized specifically for GSM8K dataset
    
    Args:
        student_answer: Student answer
        correct_answer: Correct answer
        tolerance: Numerical tolerance
        
    Returns:
        Whether the answer is correct
    """
    # First try direct string comparison (handles integer answers)
    if student_answer.strip() == correct_answer.strip():
        return True
    
    # Extract numbers for comparison
    student_num = extract_number_from_answer(student_answer)
    correct_num = extract_number_from_answer(correct_answer)
    
    if student_num is None or correct_num is None:
        # If numbers cannot be extracted, try string similarity comparison
        return student_answer.strip().lower() == correct_answer.strip().lower()
    
    # Compare numerical values (handles decimals and fractions)
    return abs(student_num - correct_num) < tolerance


def validate_math_expression(expression: str) -> bool:
    """
    Validate if mathematical expression is valid
    
    Args:
        expression: Mathematical expression
        
    Returns:
        Whether the expression is valid
    """
    try:
        # Use sympy to validate expression
        sp.sympify(expression)
        return True
    except:
        return False


def simplify_math_expression(expression: str) -> str:
    """
    Simplify mathematical expression
    
    Args:
        expression: Mathematical expression
        
    Returns:
        Simplified expression
    """
    try:
        expr = sp.sympify(expression)
        simplified = sp.simplify(expr)
        return str(simplified)
    except:
        return expression


def solve_linear_equation(equation: str) -> Optional[float]:
    """
    Solve linear equation
    
    Args:
        equation: Linear equation string
        
    Returns:
        Solution, None if no solution
    """
    try:
        # Parse equation
        expr = sp.sympify(equation)
        
        # Assume only one variable x
        x = sp.Symbol('x')
        
        # Solve
        solutions = sp.solve(expr, x)
        
        if solutions:
            return float(solutions[0])
        
        return None
    except:
        return None


def calculate_arithmetic(expression: str) -> Optional[float]:
    """
    Calculate arithmetic expression
    
    Args:
        expression: Arithmetic expression
        
    Returns:
        Calculation result, None if calculation fails
    """
    try:
        # Safe expression evaluation
        allowed_chars = set('0123456789+-*/.() ')
        if not all(c in allowed_chars for c in expression):
            return None
        
        result = eval(expression)
        return float(result)
    except:
        return None


def extract_numbers_from_text(text: str) -> List[float]:
    """
    Extract all numbers from text
    
    Args:
        text: Input text
        
    Returns:
        List of numbers
    """
    numbers = re.findall(r'-?\d+\.?\d*', text)
    result = []
    
    for num_str in numbers:
        try:
            result.append(float(num_str))
        except ValueError:
            continue
    
    return result


def format_math_answer(number: Union[int, float], precision: int = 2) -> str:
    """
    Format mathematical answer
    
    Args:
        number: Number
        precision: Precision
        
    Returns:
        Formatted answer string
    """
    if isinstance(number, int) or number.is_integer():
        return str(int(number))
    else:
        return f"{number:.{precision}f}".rstrip('0').rstrip('.')


def check_math_reasoning_consistency(response: str) -> float:
    """
    Check consistency of mathematical reasoning
    
    Args:
        response: Model response
        
    Returns:
        Consistency score (0-1)
    """
    score = 1.0
    
    # Extract all numbers
    numbers = extract_numbers_from_text(response)
    
    if len(numbers) < 2:
        return 0.5
    
    # Check reasonableness of numbers
    for i, num in enumerate(numbers):
        # Check for abnormally large numbers
        if abs(num) > 10000:
            score -= 0.1
        
        # Check for negative numbers (unreasonable in some contexts)
        if num < 0 and i < len(numbers) - 1:  # Final answer can be negative
            score -= 0.05
    
    # Check calculation logic
    lines = response.split('\n')
    for line in lines:
        if '=' in line:
            # Check calculations on both sides of equation
            parts = line.split('=')
            if len(parts) == 2:
                left = parts[0].strip()
                right = parts[1].strip()
                
                left_num = extract_number_from_answer(left)
                right_num = extract_number_from_answer(right)
                
                if left_num is not None and right_num is not None:
                    if abs(left_num - right_num) > 1e-6:
                        score -= 0.2
    
    return max(0.0, score)


def extract_math_operations(text: str) -> List[str]:
    """
    Extract mathematical operations
    
    Args:
        text: Input text
        
    Returns:
        List of mathematical operations
    """
    operations = []
    
    # Find mathematical expressions
    patterns = [
        r'\d+\s*[+\-*/]\s*\d+\s*=\s*\d+',  # Basic operations
        r'\d+\s*=\s*\d+\s*[+\-*/]\s*\d+',  # Alternative format
        r'[a-zA-Z]\s*=\s*\d+',              # Variable assignment
    ]
    
    for pattern in patterns:
        matches = re.findall(pattern, text)
        operations.extend(matches)
    
    return operations


def verify_math_step(step: str, context: str = "") -> bool:
    """
    Verify mathematical reasoning step
    
    Args:
        step: Reasoning step
        context: Context
        
    Returns:
        Whether the step is valid
    """
    # Check if contains mathematical content
    if not any(op in step for op in ['+', '-', '*', '/', '=']):
        return False
    
    # Check if contains numbers
    if not re.search(r'\d+', step):
        return False
    
    # Check for logical connectives
    logical_words = ['therefore', 'thus', 'so', 'hence', 'because', 'since', 'given']
    has_logical_word = any(word in step.lower() for word in logical_words)
    
    # If contains logical connectives, consider more valid
    return True


def calculate_confidence_score(student_answer: str, 
                              teacher_answer: str,
                              reasoning_quality: float) -> float:
    """
    Calculate confidence score
    
    Args:
        student_answer: Student answer
        teacher_answer: Teacher answer
        reasoning_quality: Reasoning quality score
        
    Returns:
        Confidence score (0-1)
    """
    # Answer correctness weight
    answer_correctness = 1.0 if is_answer_correct(student_answer, teacher_answer) else 0.0
    
    # Reasoning quality weight
    reasoning_weight = reasoning_quality
    
    # Combined score
    confidence = 0.7 * answer_correctness + 0.3 * reasoning_weight
    
    return confidence


def format_reasoning_steps(steps: List[str]) -> str:
    """
    Format reasoning steps
    
    Args:
        steps: List of reasoning steps
        
    Returns:
        Formatted reasoning text
    """
    formatted_steps = []
    
    for i, step in enumerate(steps, 1):
        # Ensure steps are numbered
        if not step.strip().startswith(('Step', str(i), 'First', 'Then')):
            step = f"Step {i}: {step}"
        
        formatted_steps.append(step)
    
    return '\n'.join(formatted_steps)


def extract_problem_type(question: str) -> str:
    """
    Extract problem type
    
    Args:
        question: Question text
        
    Returns:
        Problem type
    """
    question_lower = question.lower()
    
    # Arithmetic problems
    if any(word in question_lower for word in ['add', 'subtract', 'multiply', 'divide', 'plus', 'minus', 'times']):
        return "arithmetic"
    
    # Algebra problems
    if any(word in question_lower for word in ['solve', 'equation', 'variable', 'x =', 'y =']):
        return "algebra"
    
    # Geometry problems
    if any(word in question_lower for word in ['area', 'perimeter', 'volume', 'triangle', 'circle', 'rectangle']):
        return "geometry"
    
    # Probability problems
    if any(word in question_lower for word in ['probability', 'chance', 'likely', 'unlikely']):
        return "probability"
    
    # Word problems
    if any(word in question_lower for word in ['buy', 'sell', 'cost', 'price', 'money', 'dollar']):
        return "word_problem"
    
    return "general"


def get_difficulty_score(question: str, answer: str) -> float:
    """
    Estimate problem difficulty
    
    Args:
        question: Question text
        answer: Answer text
        
    Returns:
        Difficulty score (1-5)
    """
    difficulty = 1.0
    
    # Based on question length
    if len(question) > 200:
        difficulty += 0.5
    
    # Based on number of numbers
    numbers_in_question = len(extract_numbers_from_text(question))
    if numbers_in_question > 5:
        difficulty += 0.5
    
    # Based on number of reasoning steps
    lines_in_answer = len([line for line in answer.split('\n') if line.strip()])
    if lines_in_answer > 5:
        difficulty += 0.5
    
    # Based on problem type
    problem_type = extract_problem_type(question)
    if problem_type in ['algebra', 'geometry']:
        difficulty += 0.5
    elif problem_type == 'word_problem':
        difficulty += 0.3
    
    # Based on complexity of mathematical operations
    operations = extract_math_operations(answer)
    complex_ops = [op for op in operations if any(symbol in op for symbol in ['*', '/', '^', '**'])]
    if len(complex_ops) > 2:
        difficulty += 0.5
    
    return min(5.0, difficulty)

